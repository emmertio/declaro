"use strict";var A=Object.defineProperty;var g=(i,t,e)=>t in i?A(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var l=(i,t,e)=>(g(i,typeof t!="symbol"?t+"":t,e),e);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function w(i,t){return{meta:i,context:t}}function p(i){}class u{constructor(t,e){l(this,"valid");l(this,"value");this.valid=Promise.resolve(t),this.value=e}get invalid(){return new Promise(async(t,e)=>{const r=await this.valid;t(!r)})}onValid(t){return this.valid.then(r=>(r&&t(this.value),r))}onInvalid(t){return this.invalid.then(r=>(r&&t(this.value),r))}}function c(i,...t){const e=v(i,...t);return new u(e,i)}function d(i,...t){const e=h(i,...t);return new u(e,i)}async function v(i,...t){for(const e of t)if(!await e(i))return!1;return!0}async function h(i,...t){for(const e of t)if(await e(i))return!0;return!1}class f{constructor(){l(this,"listeners",{})}getListeners(t){return this.listeners[t]=Array.isArray(this.listeners[t])?this.listeners[t]:[],this.listeners[t]}on(t,e){return this.getListeners(t).push(e),()=>{const r=this.getListeners(t).indexOf(e),s=r>-1;return s&&this.getListeners(t).splice(r,1),s}}async emitAsync(t,...e){await this.getListeners(t).reduce(async(r,s)=>(await r,await s(...e)),Promise.resolve()).catch(r=>{console.error("Error in event listener",r)})}async emitAll(t,...e){await Promise.all(this.getListeners(t).map(r=>r(...e)))}emit(t,...e){this.getListeners(t).forEach(r=>r(...e))}}function y(i,...t){return t.reduce((e,r)=>Reflect.ownKeys(r).reduce((s,o)=>{let a=s[o],n=r[o];return Array.isArray(n)&&Array.isArray(a)?n=[...a,...n]:Array.isArray(n)&&!Array.isArray(a)?n=[a,...n].filter(m=>!!m):Array.isArray(a)&&!Array.isArray(n)&&(n=[...a??[],n]),s[o]=n,s},e),i)}class x{constructor(){l(this,"state",{});l(this,"emitter",new f)}provide(t,e){const s={value:e,key:t};this.state[t]=s}inject(t){const e=this.state[t];if(e)return e.value}singleton(t,e){const r=this.inject(t);return r||(this.provide(t,e),e)}hydrate(t,...e){return new t(this,...e)}extend(...t){return t.reduce((e,r)=>y(e,r.state),this.state)}async use(...t){return t.reduce(async(e,r)=>{await e,await r(this)},Promise.resolve(void 0))}validate(...t){return c(this,...t)}validateAny(...t){return d(this,...t)}on(t,e){return this.emitter.on(t,e)}async emit(t,...e){return await this.emitter.emitAsync(t,this,...e)}}class V{constructor(t,...e){this.context=t}}class C{static all(...t){return async e=>c(e,...t).valid}static any(...t){return async e=>d(e,...t).valid}}async function L(i){return await new Promise((t,e)=>{setTimeout(()=>{t(void 0)},i)})}const P="Hello World!";exports.Context=x;exports.ContextConsumer=V;exports.ContextValidator=C;exports.EventManager=f;exports.Validation=u;exports.allValid=v;exports.anyValid=h;exports.defineApp=w;exports.merge=y;exports.sleep=L;exports.startServer=p;exports.test=P;exports.validate=c;exports.validateAny=d;
